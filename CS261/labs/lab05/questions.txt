1) Give at least two examples from zuul-bad that demonstrated low cohesion.

One of the first things I noticed in the Game.java file is that a lot of
code was duplicated such as in the printWelcome and goRoom methods which
makes it harder to reuse the code in other parts of the program as well as
making it harder to maintain.  The Game.java file did too much of the work
in the bad version, where in the good version the tasks were better split
up between the classes.  For instance, in the Game.java the createRooms
class was responsible for creating the variables for the exits of the
rooms and in the good version the Rooms.java uses a hashmap to store the
room data and its exits, allowing additional rooms, exits, and di-
rections to be implemented much easier than in the bad version.  The
Rooms.java in the good version is more cohesive in that it is solely
responsible for the how the rooms are created and accessed as well as the
exits and the and the bad version doesn't seem to do much  at all leaving
most of its responsibility to the Game class.  Also in the bad Gama.java
file was responsible for the commandWords where in the good version the
command and commandWords classes handle more of the backend of that funct-
ionality within the game making them more defined useful and usable.

2) Give at least two examples from zuul-bad that demonstrated high coupling.

All of the members and variables (fields) of the classes are public which
makes the program harder to maintain as the a program depends on the ability
to access particular variables and members of each other. This is clearly
evident in the room and game classes.  Another example in these two classes
is how the exits were setup which was a required change in order to add add-
itional directions that the good version supported.  

3) Give at least two examples from zuul-good where the program was improved.

The good version added a new directions of movement (up, down) to the Room
class where as the bad version just had north, east, south, and west.  This
adds in more opportunity for other levels such as second/third stories to
go up, or basements and dungeons to go down.  Another improvement was the
addition of a hashmap to store the rooms in, which required additional and
much needed encapsulation by making the previously public fields private and
adding accessor methods to retrieve the data.  This was needed in order to
store the exits instead of variables which made adding the new directions
much simpler.  This provides looser coupling as well as the implementation
can change but the interface will not be affected by the change, it will
just be easier to add to and maintain for the developer(s) later on.
