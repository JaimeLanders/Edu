--------------------------------------------------------------------
CS 320 Principles of Programming Languages             RegEx Toolkit

Mark P. Jones
Portland State University
April 12, 2019
--------------------------------------------------------------------

The Haskell code in this file provides some functions for calculating
and experimenting with regular expressions

You will need to read the documentation at the top of this file in
order to make proper use of this file.  You are NOT expected or
required to study the implementation that follows (although, of
course, you are welcome to take a look if you are so inclined).

REGULAR EXPRESSIONS:
--------------------
For the purposes of this toolkit, regular expressions are specified
as strings of characters.  Only basic regular expression forms are
supported:

    rs   - A sequence expression that matches r followed by s.
    r|s  - An alternative that matches either r or s.
    r*   - A repetition that matches zero or more instances of r.
    r+   - A repetition that matches one or more instances of r.
    r?   - An optional input either matches r or is empty.
    c    - A single character regular expression matches just that
           character.  Special characters like |, *, +, (, ), and \
           should be prefixed with a backslash.  And because Haskell
           uses backslash for character escapes, this means that you
           will need to use a double backslash when entering a regular
           expression in a Haskell string: "\\*", for example, is a
           regular expression that matches the character '*'.  Note
           that spaces are interpreted literally, so "a b" is a regular
           expression that matches a three character string with a space
           between an initial 'a' and a final 'b'.
    (r)  - A parenthesized expression, used for grouping.

This is exactly the core language of regular expressions described in
the lectures, but with the addition of the (derived) + operator.  The
empty regular expression, written as an epsilon symbol in the slides
is treated as a sequence of length zero in this tool, so it can be
written as "()" or used as an empty argument for |, as in "ab|", which
matches "ab" and ""

Note that there is no support for character ranges: if you want to
match [0-9], for example, then you need to write "0|1|2|3|4|5|6|7|8|9".

Although it is possible to enter strings like these directly at
the Haskell prompt, you may find it useful to add definitions
for strings like this to a scratch file that imports this
module so that you can reference them repeatedly in interactive
calculations.

OPERATIONS:
-----------
The toolkit currently supports two operations: `strings n r`
can be used to list n strings that are generated by the regular
expression described by the string r, while `string n r`
displays only the nth string in that list.

  RegEx> strings 10 "abc"
  1) abc

  RegEx> strings 10 "a|b|c"
  1) a
  2) b
  3) c

  RegEx> strings 10 "a+b+c+"
  1) abc
  2) aabc
  3) abcc
  4) abbc
  5) aabcc
  6) abccc
  7) aaabc
  8) abbcc
  9) aabccc
  10) abcccc

  RegEx> strings 10 "ab|c"
  1) ab
  2) c

  RegEx>

As these examples show, the list of generated strings will
stop short if there are fewer that n strings in the language
described by the regular expression.

The implementation of the strings function uses some standard
techniques for interleaving and diagonalization to ensure
that all strings described by the language will eventually be
generated.  In the following example, for instance, we see that
strings does not attempt to print all of the strings generated
by the "a*" portion of the regular expression before printing
strings generated by the "b*" portion:

  RegEx> strings 10 "a*|b*"
  1) ""
  2) ""
  3) "a"
  4) "b"
  5) "aa"
  6) "bb"
  7) "aaa"
  8) "bbb"
  9) "aaaa"
  10) "bbbb"
  RegEx>

As this example shows, if the same string (in this case, the
empty string) can be obtained in multiple ways from the given
regular expression, then it will appear multiple times in the
output: there is no attempt to remove duplicates.

In some cases, the order in which the generated strings are
listed may be surprising; this is just a consequence of the
techniques that we are using to ensure that all possible
outputs are generated, even in cases where the language is
infinite.  For example, the following output shows that there
are 16 different 4 bit values, but the order in which they are
displayed does not match the order in which we might list them
if we were just counting in binary:

  RegEx> strings 20 "(0|1)(0|1)(0|1)(0|1)"
  1) "0000"
  2) "1000"
  3) "0001"
  4) "0010"
  5) "1001"
  6) "0100"
  7) "0011"
  8) "1010"
  9) "0101"
  10) "1100"
  11) "1011"
  12) "0110"
  13) "1101"
  14) "1110"
  15) "0111"
  16) "1111"

  RegEx>

As a final example, we can use `string n r` to print the nth
string that is generated for the language described by r.

  RegEx> string 10000 "0|5|(1|2|3|4|5|6|7|8|9)(0|1|2|3|4|5|6|7|8|9)*(0|5)"
  "50620"

  RegEx> 

The regular expression shown here describes all natural numbers
that are multiples of five, but note that there is no obvious
direct arithmetic relationship between the argument 10000 that
is used in this example and the output "50620" that it produces.
Remember that, although "50620" might look like a number, it
is really just a string of characters from the perspective of
formal languages!

----------------------------------------------------------------------

> module RegEx where

> import Pic
> import Data.Char   -- needed for isSpace, isAlpha, and isAlphanum

----------------------------------------------------------------------

> example = "(a|b)*ab"
> intRE   = "0|((1|2|3|4|5|6|7|8|9)(0|1|2|3|4|5|6|7|8|9)*)"
> nibble  = "(0|1)(0|1)(0|1)(0|1)"
> byte    = nibble ++ nibble

----------------------------------------------------------------------
Operators:

`strings n r` will enumerate the first `n` strings in the language for
the regular expression `r`:

> strings   :: Int -> String -> IO ()
> strings n  = printList
>            . map show
>            . take n
>            . lang
>            . parse

`string n r` will print the `n`th string in the language for the regular
expression `r`:

> string    :: Int -> String -> IO ()
> string n   = putStrLn
>            . show
>            . (!!(n-1))
>            . lang
>            . parse

> printList :: [String] -> IO ()
> printList  = putStr
>            . unlines
>            . zipWith (\i s -> show i ++ ") " ++ s) [1..]

----------------------------------------------------------------------
Abstract syntax:

> data RE = CHAR Char | EMPTY | ALT RE RE | SEQ RE RE | OPT RE | REP RE | REP1 RE
>           deriving Show

Semantics:

> type Language  = [String]

> lang          :: RE -> Language
> lang (CHAR c)  = [[c]]
> lang EMPTY     = [""]
> lang (ALT l r) = lang l `interleave` lang r
> lang (SEQ l r) = lang l `andThen`    lang r
> lang (OPT r)   = "" : lang r
> lang (REP r)   = let q = "" : lang r `andThen` q in q
> lang (REP1 r)  = let l = lang r
>                      q = l `interleave` (l `andThen` q)
>                  in q

> andThen       :: Language -> Language -> Language
> andThen xs ys  = [ x ++ y | (x, y) <- cp xs ys ]

Display:

> instance Tree RE where
>   label (CHAR c)     = [c]
>   label EMPTY        = "EMPTY"
>   label (ALT l r)    = "ALT"
>   label (SEQ l r)    = "SEQ"
>   label (OPT r)      = "?"
>   label (REP r)      = "*"
>   label (REP1 r)     = "+"
>   subtrees (CHAR c)  = []
>   subtrees EMPTY     = []
>   subtrees (ALT l r) = [l, r]
>   subtrees (SEQ l r) = [l, r]
>   subtrees (OPT r)   = [r]
>   subtrees (REP r)   = [r]
>   subtrees (REP1 r)  = [r]

----------------------------------------------------------------------
Lexical analyzer:

We would like to be able to interpret strings representing
regular expressions as a sequence of "tokens", each of which
represents one logical unit of the input string.

We start with a definition of all possible tokens types:

> data ReToken = TCHAR Char                  -- single characters
>              | TBAR | TSTAR | TPLUS | TOPT -- |, *, +, ?
>              | TOPEN | TCLOSE              -- (,  )
>                deriving (Show)

We implement lexical analysis by a function that maps lists of
characters (represented by the type [Char], which is actually
just a synonym for String) to lists of tokens (represented by
the type [ReToken]).

> lexreg            :: [Char] -> [ReToken]
> lexreg []          = []
> lexreg ('(':cs)    = TOPEN   : lexreg cs
> lexreg (')':cs)    = TCLOSE  : lexreg cs
> lexreg ('|':cs)    = TBAR    : lexreg cs
> lexreg ('+':cs)    = TPLUS   : lexreg cs
> lexreg ('*':cs)    = TSTAR   : lexreg cs
> lexreg ('?':cs)    = TOPT    : lexreg cs
> lexreg ('\\':c:cs) = TCHAR c : lexreg cs
> lexreg (c:cs)      = TCHAR c : lexreg cs

Remember that [] represents an empty list, while an expression of
the form x : xs represents a non-empty list that is constructed
by adding the value x to the front of the list xs.  For example,
1 : [2,3,4]  === [1,2,3,4].

For example, in the definition for lexreg given above, the line:

   lexreg ('(':cs) = TOPEN : lexreg cs

can be interpreted as saying that the lexreg function will
map a list of characters that begins with an open parenthesis
character, followed by a list of characters cs, into a list of
ReToken values that begins with TOPEN and is followed by the
list of tokens for cs.

With the above code in place, we can now use our lexical analyzer
to break an input into a list of constituent tokens:

  RegEx> lexreg "(a|b)*a+b"
  [TOPEN,TCHAR 'a',TBAR,TCHAR 'b',TCLOSE,TSTAR,TCHAR 'a',TPLUS,TCHAR 'b']
  RegEx>

And that's it for our lexer!

----------------------------------------------------------------------
Parser:

We'll use a handwritten parser for the simple language of regular
expression that was presented in the slides.  This parser is intended
to follow the dismabiguating rules that were specified in Q3 of the
current homework but anyone reading this should note that (a) this
code has not been extensively tested, so it may be wrong; (b) this
code has been written so that it should not provided unintended hints
about how to answer Q3.  To put it another way, understanding the
following code is probably harder than solving the homework assignment!

> parse   :: String -> RE
> parse ts = case pr (lexreg ts) of
>              (r, [])  -> r
>              (r, ts1) -> error ("unused tokens: " ++ show ts1)
>  where
>   pr, ps, pp, pa    :: [ReToken] -> (RE, [ReToken])
>   pr ts              = case ps ts of
>                          (l, TBAR:ts1) -> case pr ts1 of
>                                             (r, ts2) -> (ALT l r, ts2)
>                          (l, ts1)      -> (l, ts1)
>
>   ps ts              = case pm ts of
>                          (Nothing, ts1) -> (EMPTY, ts)
>                          (Just p,  ts1) -> seq p ts1
>                        where seq p ts1 = case pm ts1 of
>                                            (Nothing, ts2) -> (p, ts2)
>                                            (Just q,  ts2) -> seq (SEQ p q) ts2
>
>   pm, gp            :: [ReToken] -> (Maybe RE, [ReToken])
>   pm ts@(TOPEN:_)    = gp ts
>   pm ts@(TCHAR _:_)  = gp ts
>   pm ts              = (Nothing, ts)
>   gp ts              = case pp ts of (r, ts1) -> (Just r, ts1)
>
>   pp ts              = case pa ts of
>                          (r, ts1) -> rep r ts1
>                        where rep r (TSTAR:ts) = rep (REP r)  ts
>                              rep r (TPLUS:ts) = rep (REP1 r) ts
>                              rep r (TOPT :ts) = rep (OPT r)  ts
>                              rep r ts         = (r, ts)
>
>   pa (TCHAR c:ts)    = (CHAR c, ts)
>   pa (TOPEN:ts)      = case pr ts of
>                          (r, TCLOSE:ts1) -> (r, ts1)
>                          (r, ts1)        -> error ("parens: " ++ show r ++ " ; " ++ show ts1)
>   pa ts              = error "syntax error"

----------------------------------------------------------------------
The remaining code provides functions for enumerating (potentially)
infinite lists using interleaving and diagonalization:

Interleaving lists.  (The union of two countable sets is countable.)

> interleave          :: [a] -> [a] -> [a]
> interleave []     ys = ys
> interleave (x:xs) ys = x : interleave ys xs

We can use the fconcat function to enumerate the elements in a
list of lists when we know that the list itself is finite (even
if some of the lists that it contains are not):

> fconcat    :: [[a]] -> [a]
> fconcat xss = case filter (not . null) xss of
>                []  -> []
>                yss -> map head yss ++ fconcat (map tail yss)

If we want to enumerate the values in a list of lists and there is
a possibility that the outer list is infinite, then we will need a
more sophisticated "diagonalization" algorithm.  (The union of a
countable set of countable sets is countable.)

> diag :: [[a]] -> [a]
> diag  = concat . cols
>  where
>   cols                    :: [[a]] -> [[a]]
>   cols []                  = []
>   cols ([]:xss)            = cols xss
>   cols ((x:xs):xss)        = [x] : formCols xs (cols xss)
>
>   formCols                :: [a] -> [[a]] -> [[a]]
>   formCols (x:xs) (ys:yss) = (x:ys) : formCols xs yss
>   formCols []     yss      = yss
>   formCols xs     []       = [ [x] | x <- xs ]

Diagonalization can be used, for example, to enumerate the cartesian
product of an arbitrary pair of lists, even if one or both of the
lists is not finite.  (The product of two countable sets is countable.)

> cp      :: [a] -> [b] -> [(a, b)]
> cp xs ys = diag [ [ (x,y) | x <- xs ] | y <- ys ]

----------------------------------------------------------------------
